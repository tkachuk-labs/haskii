module Main
  ( main,
  )
where

import CoreMonad (getDynFlags)
import Data.List.Extra (nubOrdOn)
import qualified Data.Text as T
import GHC (DynFlags (..), runGhc)
import GHC.Paths (libdir)
import GHC.SourceGen
import GHC.SourceGen.Decl (prefixCon)
import GHC.SourceGen.Module (thingAll)
import GHC.SourceGen.Pretty (showPpr)
import GhcMonad (liftIO)
import qualified Haskii.Figlet.FLF as FLF
import Haskii.Figlet.Types (FLF)
import System.Directory (removeFile)
import System.Directory.Tree
  ( AnchoredDirTree (..),
    DirTree (..),
    readDirectory,
  )
import System.Environment (getProgName)
import qualified System.FilePath.Posix as F
import qualified Text.Casing as T
import Universum

newtype FLFName
  = FLFName String
  deriving (Eq, Ord, Show)

data FLFData
  = FLFData FLFName FLF
  deriving (Show)

dir :: String
dir = "figlet-fonts"

parseFLFs :: IO [FLFData]
parseFLFs = do
  dt0 <- readDirectory $ "./" <> dir
  dt1 <- case dirTree dt0 of
    Dir {name = x, contents = xs} | x == dir -> pure xs
    e -> nuke e
  flfs <-
    mapM
      ( \case
          File {name = x} -> parseFLFData x
          e -> nuke e
      )
      dt1
  pure . nubOrdOn (\(FLFData x _) -> x) . catMaybes $ flfs
  where
    nuke e = fail $ "Unexpected DirTree " <> show e

parseFLFData :: String -> IO (Maybe FLFData)
parseFLFData file0 =
  this `catch` \(e :: SomeException) -> do
    putStrLn $ fileName <> " ==> removing because " <> show e
    removeFile fileName
    pure Nothing
  where
    fileName = F.joinPath ["./", dir, file0]
    this = do
      res <- FLF.load fileName
      case res of
        Left e -> do
          putStrLn $ fileName <> " ==> removing because " <> e
          removeFile fileName
          pure Nothing
        Right x ->
          pure . Just $
            FLFData
              ( FLFName . T.pascal
                  . T.unpack
                  . T.replace " " "-"
                  . T.pack
                  . F.dropExtension
                  $ file0
              )
              x

--genFLFs :: DynFlags -> String -> FLFData -> IO ()
--genFLFs dflags prog flf =
--  defMessage
--    & #file
--      .~ [ defMessage
--             & #name .~ "Proto/SignableOrphan.hs"
--             & #content .~ header <> "\n\n" <> body
--         ]
--  where
--    protoMods :: [ProtoMod]
--    protoMods =
--      (\x -> ProtoMod (parseModName x) $ parseModTypes x)
--        <$> req ^. #protoFile
--    imports :: [ImportDecl']
--    imports =
--      qualified'
--        <$> ( [ import' "Universum",
--                import' "Data.Signable",
--                import' "GHC.List"
--              ]
--                <> ( protoMods
--                       >>= ( \x ->
--                               let n = modName x
--                                in import' . fromString <$> [n, n <> "_Fields"]
--                           )
--                   )
--            )
--    body :: Text
--    body =
--      pack . showPpr dflags $
--        module'
--          (Just "Proto.SignableOrphan")
--          (Just [])
--          imports
--          (protoMods >>= mkImpls)
--    header :: Text
--    header =
--      Data.Text.intercalate "\n" $
--        [ "{- This file was auto-generated by the "
--            <> pack prog
--            <> " program. -}",
--          "{-# OPTIONS_GHC -fno-warn-orphans #-}",
--          "{-# OPTIONS_GHC -fno-warn-unused-imports #-}",
--          "{-# LANGUAGE NoImplicitPrelude #-}",
--          "{-# LANGUAGE OverloadedStrings #-}"
--        ]

showFLFModule :: FLFData -> String
showFLFModule (FLFData (FLFName x) _) = "Haskii.Figlet.Fonts." <> x

mkFontType :: [FLFData] -> HsDecl'
mkFontType flfs =
  data'
    "Font"
    []
    ((\(FLFData (FLFName x) _) -> prefixCon (fromString x) []) <$> flfs)
    [deriving' [var "Eq", var "Ord", var "Show", var "Read"]]

mkGetFLF :: [FLFData] -> HsDecl'
mkGetFLF flfs =
  funBinds "getFLF" $
    ( \flf@(FLFData (FLFName x) _) ->
        match
          [conP (fromString x) []]
          (var . fromString $ showFLFModule flf <> ".getFLF")
    )
      <$> flfs

genFLFsIndex :: DynFlags -> String -> [FLFData] -> IO ()
genFLFsIndex dflags prog flfs =
  putStrLn $ header <> "\n\n" <> body
  where
    imports :: [ImportDecl']
    imports =
      qualified'
        <$> ( [ import' "Universum",
                import' "GHC.List",
                import' "Haskii.Figlet.Types"
              ]
                <> (import' . fromString . showFLFModule <$> flfs)
            )
    body :: Text
    body =
      T.pack . showPpr dflags $
        module'
          (Just "Haskii.Figlet.Font")
          ( Just
              [ thingAll "Font",
                thingAll "getFLF"
              ]
          )
          imports
          [ mkFontType flfs,
            typeSig "getFLF" $ var "Font" --> var "Haskii.Figlet.Types.FLF",
            mkGetFLF flfs
          ]
    header :: Text
    header =
      T.intercalate
        "\n"
        [ "{- This file was auto-generated by the "
            <> T.pack prog
            <> " program. -}",
          "{-# LANGUAGE NoImplicitPrelude #-}",
          "{-# LANGUAGE OverloadedStrings #-}"
        ]

main :: IO ()
main = do
  prog <- getProgName
  flfs <- parseFLFs
  runGhc (Just libdir) $ do
    dflags <- getDynFlags
    liftIO $ genFLFsIndex dflags prog flfs
--mapM_ (liftIO . genFLFs dflags prog) flfs
