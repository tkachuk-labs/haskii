module Main
  ( main,
  )
where

import CoreMonad (getDynFlags)
import qualified Data.Char as C
import Data.List.Extra (nubOrdOn)
import qualified Data.Text as T
import GHC (DynFlags, runGhc)
import GHC.Paths (libdir)
import GHC.SourceGen
import GHC.SourceGen.Decl (prefixCon)
import GHC.SourceGen.Module (thingAll)
import GHC.SourceGen.Pretty (showPpr)
import GhcMonad (liftIO)
import qualified Haskii.Figlet.FLF as FLF
import Haskii.Figlet.Types (FLF)
import qualified Options.Applicative as Opt
import System.Directory (createDirectoryIfMissing, removeFile)
import System.Directory.Tree
  ( AnchoredDirTree (..),
    DirTree (..),
    readDirectory,
  )
import System.Environment (getProgName)
import qualified System.FilePath.Posix as F
--import System.IO (writeFile)
import qualified Text.Casing as T
import Universum

newtype FLFName
  = FLFName String
  deriving (Eq, Ord, Show)

data FLFData
  = FLFData FLFName FLF
  deriving (Show)

data Arg
  = Arg
      { argInputDir :: String,
        argOutputDir :: String
      }
  deriving (Eq, Ord, Show)

dir :: String
dir = "figlet-fonts"

parseFLFs :: IO [FLFData]
parseFLFs = do
  dt0 <- readDirectory $ "./" <> dir
  dt1 <- case dirTree dt0 of
    Dir {name = x, contents = xs} | x == dir -> pure xs
    e -> nuke e
  flfs <-
    mapM
      ( \case
          File {name = x} -> parseFLFData x
          e -> nuke e
      )
      dt1
  pure
    . sortOn (\(FLFData x _) -> x)
    . nubOrdOn (\(FLFData x _) -> x)
    . catMaybes
    $ flfs
  where
    nuke e = fail $ "Unexpected DirTree " <> show e

parseFLFData :: String -> IO (Maybe FLFData)
parseFLFData file0 =
  this `catch` \(e :: SomeException) -> do
    putStrLn $ fileName <> " ==> removing because " <> show e
    removeFile fileName
    pure Nothing
  where
    fileName = F.joinPath ["./", dir, file0]
    flfName =
      let x =
            T.pascal
              . T.unpack
              . T.replace " " "-"
              . T.pack
              . F.dropExtension
              $ file0
       in FLFName $
            if maybe False C.isAlpha $ safeHead x
              then x
              else "The" <> x
    this = do
      res <- FLF.load fileName
      case res of
        Left e -> do
          putStrLn $ fileName <> " ==> removing because " <> e
          removeFile fileName
          pure Nothing
        Right x ->
          pure . Just $
            FLFData flfName x

showFLFModule :: FLFData -> String
showFLFModule (FLFData (FLFName x) _) = "Haskii.Figlet.Font." <> x

mkFontType :: [FLFData] -> HsDecl'
mkFontType flfs =
  data'
    "Font"
    []
    ((\(FLFData (FLFName x) _) -> prefixCon (fromString x) []) <$> flfs)
    [ deriving'
        [ var "Universum.Eq",
          var "Universum.Ord",
          var "Universum.Show",
          var "Universum.Read"
        ]
    ]

genFLF :: DynFlags -> String -> Arg -> FLFData -> IO ()
genFLF dflags prog arg flf@(FLFData (FLFName flfName) flf0) = do
  createDirectoryIfMissing True outputDir
  writeFile
    (outputDir <> "/" <> flfName <> ".hs")
    $ header <> "\n\n" <> body
  where
    outputDir :: String
    outputDir = (argOutputDir arg) <> "/Haskii/Figlet/Font"
    header :: Text
    header =
      T.intercalate
        "\n"
        [ "{- This file was auto-generated by the "
            <> T.pack prog
            <> " program. -}",
          "{-# LANGUAGE NoImplicitPrelude #-}"
        ]
    imports :: [ImportDecl']
    imports =
      [ import' "Universum",
        import' "Haskii.Figlet.Types",
        import' "Data.Map"
      ]
    body :: Text
    body =
      ( T.pack . showPpr dflags $
          module'
            (Just . fromString $ showFLFModule flf)
            (Just [var "getFLF"])
            imports
            [typeSig "getFLF" $ var "FLF"]
      )
        <> "\ngetFLF = "
        <> show flf0

genFLFsIndex :: DynFlags -> String -> Arg -> [FLFData] -> IO ()
genFLFsIndex dflags prog arg flfs = do
  createDirectoryIfMissing True outputDir
  writeFile outputFile $ header <> "\n\n" <> body
  where
    outputDir :: String
    outputDir = (argOutputDir arg) <> "/Haskii/Figlet"
    outputFile :: String
    outputFile = outputDir <> "/Font.hs"
    header :: Text
    header =
      T.intercalate
        "\n"
        [ "{- This file was auto-generated by the "
            <> T.pack prog
            <> " program. -}",
          "{-# LANGUAGE NoImplicitPrelude #-}"
        ]
    imports :: [ImportDecl']
    imports =
      qualified'
        <$> ( [ import' "Universum",
                import' "Haskii.Figlet.Types"
              ]
                <> (import' . fromString . showFLFModule <$> flfs)
            )
    body :: Text
    body =
      T.pack . showPpr dflags $
        module'
          (Just "Haskii.Figlet.Font")
          ( Just
              [ thingAll "Font",
                var "getFLF"
              ]
          )
          imports
          [ mkFontType flfs,
            typeSig "getFLF" $ var "Font" --> var "Haskii.Figlet.Types.FLF",
            mkGetFLF flfs
          ]
    mkGetFLF :: [FLFData] -> HsDecl'
    mkGetFLF =
      funBinds "getFLF"
        . fmap
          ( \flf@(FLFData (FLFName x) _) ->
              match
                [conP (fromString x) []]
                (var . fromString $ showFLFModule flf <> ".getFLF")
          )

argParser :: Opt.Parser Arg
argParser =
  Arg
    <$> Opt.strOption
      ( Opt.long "input-dir"
          <> Opt.short 'i'
          <> Opt.metavar "INPUT_DIR"
          <> Opt.help "Input directory where figlet fonts are located"
      )
    <*> Opt.strOption
      ( Opt.long "output-dir"
          <> Opt.short 'o'
          <> Opt.metavar "OUTPUT_DIR"
          <> Opt.help "Output directory where Haskell Figlet fonts are written"
      )

getArg :: IO Arg
getArg = Opt.execParser opts
  where
    opts =
      Opt.info
        (argParser <**> Opt.helper)
        ( Opt.fullDesc
            <> Opt.progDesc
              "Take Figlet fonts from INPUT_DIR and generate corresponding Haskell files in OUTPUT_DIR"
            <> Opt.header
              "haskii-figlet-gen - a Figlet to Haskell compiler"
        )

main :: IO ()
main = do
  arg <- getArg
  prog <- getProgName
  flfs <- parseFLFs
  runGhc (Just libdir) $ do
    dflags <- getDynFlags
    liftIO $ genFLFsIndex dflags prog arg flfs
    mapM_ (liftIO . genFLF dflags prog arg) flfs
