module Main
  ( main,
  )
where

import CoreMonad (getDynFlags)
import qualified Data.Char as C
import Data.List.Extra (nubOrdOn)
import qualified Data.Text as T
import GHC (DynFlags (..), runGhc)
import GHC.Paths (libdir)
import GHC.SourceGen
import GHC.SourceGen.Decl (prefixCon)
import GHC.SourceGen.Module (thingAll)
import GHC.SourceGen.Pretty (showPpr)
import GhcMonad (liftIO)
import qualified Haskii.Figlet.FLF as FLF
import Haskii.Figlet.Types (FLF)
import System.Directory (removeFile)
import System.Directory.Tree
  ( AnchoredDirTree (..),
    DirTree (..),
    readDirectory,
  )
import System.Environment (getProgName)
import qualified System.FilePath.Posix as F
--import System.IO (writeFile)
import qualified Text.Casing as T
import Universum

newtype FLFName
  = FLFName String
  deriving (Eq, Ord, Show)

data FLFData
  = FLFData FLFName FLF
  deriving (Show)

dir :: String
dir = "figlet-fonts"

parseFLFs :: IO [FLFData]
parseFLFs = do
  dt0 <- readDirectory $ "./" <> dir
  dt1 <- case dirTree dt0 of
    Dir {name = x, contents = xs} | x == dir -> pure xs
    e -> nuke e
  flfs <-
    mapM
      ( \case
          File {name = x} -> parseFLFData x
          e -> nuke e
      )
      dt1
  pure
    . sortOn (\(FLFData x _) -> x)
    . nubOrdOn (\(FLFData x _) -> x)
    . catMaybes
    $ flfs
  where
    nuke e = fail $ "Unexpected DirTree " <> show e

parseFLFData :: String -> IO (Maybe FLFData)
parseFLFData file0 =
  this `catch` \(e :: SomeException) -> do
    putStrLn $ fileName <> " ==> removing because " <> show e
    removeFile fileName
    pure Nothing
  where
    fileName = F.joinPath ["./", dir, file0]
    flfName =
      let x =
            T.pascal
              . T.unpack
              . T.replace " " "-"
              . T.pack
              . F.dropExtension
              $ file0
       in FLFName $
            if maybe False C.isAlpha $ safeHead x
              then x
              else "The" <> x
    this = do
      res <- FLF.load fileName
      case res of
        Left e -> do
          putStrLn $ fileName <> " ==> removing because " <> e
          removeFile fileName
          pure Nothing
        Right x ->
          pure . Just $
            FLFData flfName x

showFLFModule :: FLFData -> String
showFLFModule (FLFData (FLFName x) _) = "Haskii.Figlet.Font." <> x

mkFontType :: [FLFData] -> HsDecl'
mkFontType flfs =
  data'
    "Font"
    []
    ((\(FLFData (FLFName x) _) -> prefixCon (fromString x) []) <$> flfs)
    [ deriving'
        [ var "Universum.Eq",
          var "Universum.Ord",
          var "Universum.Show",
          var "Universum.Read"
        ]
    ]

genFLF :: DynFlags -> String -> FLFData -> IO ()
genFLF dflags prog flf@(FLFData (FLFName flfName) flf0) =
  writeFile
    ("./Haskii/Haskii/Figlet/Font/" <> flfName <> ".hs")
    $ header <> "\n\n" <> body
  where
    header :: Text
    header =
      T.intercalate
        "\n"
        [ "{- This file was auto-generated by the "
            <> T.pack prog
            <> " program. -}",
          "{-# LANGUAGE NoImplicitPrelude #-}"
        ]
    imports :: [ImportDecl']
    imports =
      [ import' "Universum",
        import' "Haskii.Figlet.Types",
        import' "Data.Map"
      ]
    body :: Text
    body =
      ( T.pack . showPpr dflags $
          module'
            (Just . fromString $ showFLFModule flf)
            (Just [var "getFLF"])
            imports
            [typeSig "getFLF" $ var "FLF"]
      )
        <> "\ngetFLF = "
        <> show flf0

genFLFsIndex :: DynFlags -> String -> [FLFData] -> IO ()
genFLFsIndex dflags prog flfs =
  writeFile
    "./Haskii/Haskii/Figlet/Font.hs"
    $ header <> "\n\n" <> body
  where
    header :: Text
    header =
      T.intercalate
        "\n"
        [ "{- This file was auto-generated by the "
            <> T.pack prog
            <> " program. -}",
          "{-# LANGUAGE NoImplicitPrelude #-}"
        ]
    imports :: [ImportDecl']
    imports =
      qualified'
        <$> ( [ import' "Universum",
                import' "Haskii.Figlet.Types"
              ]
                <> (import' . fromString . showFLFModule <$> flfs)
            )
    body :: Text
    body =
      T.pack . showPpr dflags $
        module'
          (Just "Haskii.Figlet.Font")
          ( Just
              [ thingAll "Font",
                var "getFLF"
              ]
          )
          imports
          [ mkFontType flfs,
            typeSig "getFLF" $ var "Font" --> var "Haskii.Figlet.Types.FLF",
            mkGetFLF flfs
          ]
    mkGetFLF :: [FLFData] -> HsDecl'
    mkGetFLF =
      funBinds "getFLF"
        . fmap
          ( \flf@(FLFData (FLFName x) _) ->
              match
                [conP (fromString x) []]
                (var . fromString $ showFLFModule flf <> ".getFLF")
          )

main :: IO ()
main = do
  prog <- getProgName
  flfs <- parseFLFs
  runGhc (Just libdir) $ do
    dflags <- getDynFlags
    liftIO $ genFLFsIndex dflags prog flfs
    mapM_ (liftIO . genFLF dflags prog) flfs
