module Main
  ( main,
  )
where

import CoreMonad (getDynFlags)
import Data.List.Extra (nubOrdOn)
import qualified Data.Text as T
import GHC (DynFlags (..), runGhc)
import GHC.Paths (libdir)
import GHC.SourceGen
import GHC.SourceGen.Decl (prefixCon)
import GHC.SourceGen.Module (thingAll)
import GHC.SourceGen.Pretty (showPpr)
import GhcMonad (liftIO)
import qualified Haskii.Figlet.FLF as FLF
import Haskii.Figlet.Types (FLF)
import System.Directory (removeFile)
import System.Directory.Tree
  ( AnchoredDirTree (..),
    DirTree (..),
    readDirectory,
  )
import System.Environment (getProgName)
import qualified System.FilePath.Posix as F
import qualified Text.Casing as T
import Universum

newtype FLFName
  = FLFName String
  deriving (Eq, Ord, Show)

data FLFData
  = FLFData FLFName FLF
  deriving (Show)

dir :: String
dir = "figlet-fonts"

parseFLFs :: IO [FLFData]
parseFLFs = do
  dt0 <- readDirectory $ "./" <> dir
  dt1 <- case dirTree dt0 of
    Dir {name = x, contents = xs} | x == dir -> pure xs
    e -> nuke e
  flfs <-
    mapM
      ( \case
          File {name = x} -> parseFLFData x
          e -> nuke e
      )
      dt1
  pure . nubOrdOn (\(FLFData x _) -> x) . catMaybes $ flfs
  where
    nuke e = fail $ "Unexpected DirTree " <> show e

parseFLFData :: String -> IO (Maybe FLFData)
parseFLFData file0 =
  this `catch` \(e :: SomeException) -> do
    putStrLn $ fileName <> " ==> removing because " <> show e
    removeFile fileName
    pure Nothing
  where
    fileName = F.joinPath ["./", dir, file0]
    this = do
      res <- FLF.load fileName
      case res of
        Left e -> do
          putStrLn $ fileName <> " ==> removing because " <> e
          removeFile fileName
          pure Nothing
        Right x ->
          pure . Just $
            FLFData
              ( FLFName . T.pascal
                  . T.unpack
                  . T.replace " " "-"
                  . T.pack
                  . F.dropExtension
                  $ file0
              )
              x

showFLFModule :: FLFData -> String
showFLFModule (FLFData (FLFName x) _) = "Haskii.Figlet.Fonts." <> x

mkFontType :: [FLFData] -> HsDecl'
mkFontType flfs =
  data'
    "Font"
    []
    ((\(FLFData (FLFName x) _) -> prefixCon (fromString x) []) <$> flfs)
    [deriving' [var "Eq", var "Ord", var "Show", var "Read"]]

genFLF :: DynFlags -> String -> FLFData -> IO ()
genFLF dflags prog flf@(FLFData _ flf0) =
  putStrLn $ header <> "\n\n" <> body
  where
    header :: Text
    header =
      T.intercalate
        "\n"
        [ "{- This file was auto-generated by the "
            <> T.pack prog
            <> " program. -}",
          "{-# LANGUAGE NoImplicitPrelude #-}",
          "{-# LANGUAGE OverloadedStrings #-}"
        ]
    imports :: [ImportDecl']
    imports =
      qualified'
        <$> [ import' "Universum",
              import' "GHC.List",
              import' "Haskii.Figlet.Types",
              import' "Haskii.Figlet.Font"
            ]
    body :: Text
    body =
      ( T.pack . showPpr dflags $
          module'
            (Just . fromString $ "Haskii.Figlet.Font." <> showFLFModule flf)
            (Just [thingAll "getFLF"])
            imports
            [ typeSig "getFLF" $
                var "Haskii.Figlet.Font.Font" --> var "Haskii.Figlet.Types.FLF"
            ]
      )
        <> "\ngetFLF = "
        <> show flf0

genFLFsIndex :: DynFlags -> String -> [FLFData] -> IO ()
genFLFsIndex dflags prog flfs =
  putStrLn $ header <> "\n\n" <> body
  where
    header :: Text
    header =
      T.intercalate
        "\n"
        [ "{- This file was auto-generated by the "
            <> T.pack prog
            <> " program. -}",
          "{-# LANGUAGE NoImplicitPrelude #-}",
          "{-# LANGUAGE OverloadedStrings #-}"
        ]
    imports :: [ImportDecl']
    imports =
      qualified'
        <$> ( [ import' "Universum",
                import' "GHC.List",
                import' "Haskii.Figlet.Types"
              ]
                <> (import' . fromString . showFLFModule <$> flfs)
            )
    body :: Text
    body =
      T.pack . showPpr dflags $
        module'
          (Just "Haskii.Figlet.Font")
          ( Just
              [ thingAll "Font",
                thingAll "getFLF"
              ]
          )
          imports
          [ mkFontType flfs,
            typeSig "getFLF" $ var "Font" --> var "Haskii.Figlet.Types.FLF",
            mkGetFLF flfs
          ]
    mkGetFLF :: [FLFData] -> HsDecl'
    mkGetFLF =
      funBinds "getFLF"
        . fmap
          ( \flf@(FLFData (FLFName x) _) ->
              match
                [conP (fromString x) []]
                (var . fromString $ showFLFModule flf <> ".getFLF")
          )

main :: IO ()
main = do
  prog <- getProgName
  flfs <- parseFLFs
  runGhc (Just libdir) $ do
    dflags <- getDynFlags
    liftIO $ genFLFsIndex dflags prog flfs
    mapM_ (liftIO . genFLF dflags prog) flfs
